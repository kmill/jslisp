;;;;;;;;;;;;;;;;;;;;
;; 2_compiler.jsl ;;
;;;;;;;;;;;;;;;;;;;;

;; This is basically lifted from 0_compiler.html

;; This should be compiled using 1_compiler.jsl, and then so should
;; 1_compiler.jsl.  This produces 3_compiler.js

;; bootstrap
(prim:def cons (prim:fun (a b) (prim:cons a b)))

;; Make some macros to tie into the primitives
(macro:set! 'fun
  (prim:fun (_ # stuff) (cons 'prim:fun stuff)))
(macro:set! 'do
  (fun (_ # stuff) (cons 'prim:do stuff)))
(macro:set! 'def
  (fun (_ # stuff) (cons 'prim:def stuff)))
(macro:set! 'set!
  (fun (_ # stuff) (cons 'prim:set! stuff)))

;; tie some primitives to lisp functions
(def cons? (fun (a) (prim:cons? a)))
(def head (fun (a) (prim:head a)))
(def tail (fun (a) (prim:tail a)))
(def nil (fun () (prim:nil)))
(def nil? (fun (a) (prim:nil? a)))
(def ffi (fun (c) (prim:ffi c)))

;; Tie into javascript for the self-evaluating types
(def number? (ffi "
  (function (x) {
    return typeof x === \"number\";
  })
"))
(def true (ffi "true"))
(def false (ffi "false"))
(def null (ffi "null"))
(def null? (ffi "
  (function (x) {
    return x === null;
  })
"))

(def apply (ffi "(function (f, args) {
  var as = [];
  while (!(args instanceof Nil)) {
    as.push(args.head);
    args = args.tail;
  }
  return f.apply(undefined, as);
})"))
(def error (ffi "(function (s) { throw new Error(s); })"))

; (list a b c ...) => (a b c ...)
(def list (fun args args))

; (if cond1 cons1 cond2 cons2 ... [alt])
(macro:set! 'if
  (fun (_ # conds)
    (prim:if (nil? conds)
      null
      (prim:if (nil? (tail conds))
        (head conds)
        (list 'prim:if (head conds)
							(head (tail conds))
							(cons 'if (tail (tail conds))))))))
(def otherwise true)

; (defmac (macro a b c) ...)
; or (defmac s (fun ...))
(macro:set! 'defmac
  (fun (_ args # body)
    (if (cons? args)
      (list 'macro:set! (list 'quote (head args))
        (list 'fun (cons '_ (tail args))
          (cons 'do body)))
      ; reverse compatibility so we can compile 1_compiler.jsl
      (list 'macro:set! (list 'quote args) (head body)))))

(defmac (when pred # body)
  (list 'if pred (cons 'do body)))

; (defun (f a1 a2 ...) body...)
(defmac (defun v # body)
  (list 'def (head v) (list 'fun (tail v) (cons 'do body))))

;;; Operations on lists

(defun (foldl op start lst)
  (defun (_foldl acc lst)
    (if (nil? lst)
      acc
      (_foldl (op acc (head lst)) (tail lst))))
  (_foldl start lst))

(defun (foldr op end lst)
  (if (nil? lst)
    end
    (op (head lst) (foldr op end (tail lst)))))

(defun (map op lst)
  (if (nil? lst)
    '()
    (cons (op (head lst)) (map op (tail lst)))))
(defun (each op lst)
  (if (nil? lst)
    null
    (do (op (head lst))
        (each op (tail lst)))))
(defun (reverse lst) (foldl (flip cons) '() lst))

(defun (filter pred lst)
  (if (nil? lst)        '()
      (pred (head lst)) (cons (head lst) (filter pred (tail lst)))
      otherwise         (filter pred (tail lst))))

; Association lists
(defun (a:keys alist)
  (if (nil? alist)        '()
      (nil? (tail alist)) (error "Improper alist")
      otherwise           (cons (head alist)
                                (a:keys (tail (tail alist))))))
(defun (a:values alist)
  (if (nil? alist)        '()
      (nil? (tail alist)) (error "Improper alist")
      otherwise           (cons (head (tail alist))
                                (a:values (tail (tail alist))))))
    

; Let via basic let->lambda

(defmac (let bindings # body)
  (cons (list 'fun (a:keys bindings) (cons 'do body))
				(a:values bindings)))

; Operators
(def js:+ (ffi "(function (a, b) { return a + b; })"))
(defun (ffi-make-binop op)
  (ffi (js:+ (js:+ "(function (a, b) { return a " op) " b; })")))
(def js:- (ffi-make-binop '-))
(def js:* (ffi-make-binop '*))
(def js:/ (ffi-make-binop '/))
(def js:% (ffi-make-binop '%))
(def js:< (ffi-make-binop '< ))
(def js:> (ffi-make-binop '> ))
(def js:<= (ffi-make-binop '<= ))
(def js:>= (ffi-make-binop '>= ))
(def js:=== (ffi-make-binop '===))
(def js:toString (ffi "(function (a) { return \"\" + a; })"))
(def js:toNum (ffi "(function (a) { return +a; })"))
(def NaN? (ffi "(function (a) { return isNaN(a); })"))

(def / js:/)
(def % js:%)
(def < js:<)
(def > js:>)
(def <= js:<=)
(def >= js:>=)
(def = js:===)

(def ++ (ffi "(function () {
  return Array.prototype.join.call(arguments, '');
})"))

(defun (+ # args) (foldl js:+ 0 args))
(defun (* # args) (foldl js:* 1 args))

(defun (- s # args)
  (if (nil? args)
    (js:- 0 s)
    (js:- s (apply + args))))

(defun (append2 lst1 lst2)
  (foldr cons lst2 lst1))

(defun (append # lsts)
  (foldr append2 '() lsts))

(defun (map-append f lst)
  (apply append (map f lst)))

(def gensym
  (let (count 0)
    (fun ()
      (set! count (+ 1 count))
      (++ "#gensym#" count))))

;;; Strings
(def s:length (ffi "(function (s) {
  return s.length;
})"))
(def s:charAt (ffi "(function (s, i) {
  return s.charAt(i);
})"))
(def s:charCodeAt (ffi "(function (s, i) {
  return s.charCodeAt(i);
})"))
(def s:slice (ffi "(function (s) {
  var args = _.toArray(arguments);
  args.shift();
  return s.slice.apply(s, args);
})"))
(def s:indexOf (ffi "(function (s) {
  var args = _.toArray(arguments);
  args.shift();
  return s.indexOf.apply(s, args);
})"))
(def s:fromCharCode (ffi "String.fromCharCode"))
(def s:split (ffi "(function (s) {
  var args = _.toArray(arguments);
  args.shift();
  var ret = new Nil();
  return s.split.apply(s, args);
})"))

(defun (intercalate sep ss)
  (if (nil? ss)        ""
  	  (nil? (tail ss)) (head ss)
	  	otherwise        (++ (head ss) sep
		  	                   (intercalate sep (tail ss)))))

;;; Dictionaries
(def js:dictConst (ffi "function Dict () {}; Dict"))
(def js:makeDict ((ffi "(function (con) {
  return function () { return new con(); };
})") js:dictConst))
(def dict? ((ffi "(function (con) {
  return function (a) { return a instanceof con; };
})") js:dictConst))
(def dict:get (ffi "(function (o, k, def) {
  if (_.has(o, k)) {
    return o[k];
  } else if (def === undefined) {
    throw new Error(\"Key error: \" + k);
  } else {
    return def;
  }
})"))
(def dict:set! (ffi "(function (o, k, v) {
  o[k] = v;
  return null;
})"))
(def dict:has? (ffi "(function (o, k) {
  return _.has(o, k);
})"))
(defun (dict # pairs)
  (defun (add-pairs d pairs)
    (if (not (nil? pairs))
      (do (dict:set! d (head pairs) (head (tail pairs)))
          (add-pairs d (tail (tail pairs))))))
  (let (d (js:makeDict))
    (add-pairs d pairs)
    d))

;;; Logical operators

(defmac (and v # args)
  (if (nil? args)
    v
    (let (vvar (gensym))
      (list 'let (list vvar v)
        (list 'if vvar (cons 'and args) vvar)))))
(defmac (or v # args)
  (if (nil? args)
    v
    (let (vvar (gensym))
      (list 'let (list vvar v)
        (list 'if vvar vvar (cons 'or args))))))
(defun (not x) (if x false true))
(defun (!= a b) (not (= a b)))

(defun (all lst)
  (and (head lst) (all (tail lst))))
(defun (any lst)
  (or (head lst) (any (tail lst))))

;;; More lists
(defun (length lst)
  (defun (_length lst acc)
    (if (nil? lst)
      acc
      (_length (tail lst) (+ acc 1))))
  (_length lst 0))
(defun (nth lst i)
  (if (< i 0)    (nth lst (+ i (length lst)))
      (nil? lst) (error "List index out of bounds.")
      (= i 0)    (head lst)
      otherwise  (nth (tail lst) (- i 1))))

;;; Functions

; compose
(defun (. f # args)
  (if (nil? args)
    f
    (let (composed (apply . args))
      (fun a (f (apply composed a))))))
(defun (curry f)
  (fun (x) (fun (y) (f x y))))
(defun (uncurry f)
  (fun (x y) ((f x) y)))
(defun (partial f # args1)
  (fun args2
    (apply f (append args1 args2))))
(defun (flip f)
  (fun (x y)
    (f y x)))
; also known as 'call'
(defun ($ f # args)
  (apply f args))
(defun (|> x # funcs)
  (if (nil? funcs)
    x
    (apply |> (cons ((head funcs) x) (tail funcs)))))
(defun (id x) x)
(defun (const x) (fun (_) x))

;;; More control flow

(defmac let* (fun (_ bindings # body)
  (if (nil? bindings)
    (cons 'do body)
    (list 'let (list (head bindings) (head (tail bindings)))
      (append (list 'let* (tail (tail bindings)))
              body)))))

(defmac do1 (fun (_ fst # body)
  (let (v (gensym))
    (list 'let (list v fst)
      (cons 'do body)
      v))))

(defmac foreach (fun (_ v in lst # body)
  (if (not (= in 'in))
    (error "Missing keyword 'in' in foreach.")
    (list 'each (list 'fun (list v) (cons 'do body)) lst))))

(defmac switch (fun (_ v # cases)
  (defun (_switch vv cases)
    (if (nil? cases)        null
        (nil? (tail cases)) (head cases)
        otherwise
          (list 'if (list '= vv (head cases)) (head (tail cases)) (_switch vv (tail (tail cases))))))
  (let (vv (gensym))
    (list 'let (list vv v)
      (_switch vv cases)))))

;;; Output

(def js:print (ffi "(function () { _.each(arguments, output); return null; })"))
(defun (print # xs)
  (foreach x in xs
    (js:print (repr x))))

(defun (repr x)
  (defun (repr-tail xs)
    (if (nil? (tail xs))   (++ (repr (head xs)) ")")
        (cons? (tail xs))  (++ (repr (head xs)) " " (repr-tail (tail xs)))
        otherwise          (++ (repr (head xs)) " # " (repr (tail xs)) ")")))
  (if (nil? x)  "()"
      (cons? x) (switch (head x)
                  'quote (++ "'" (repr (head (tail x))))
                  (++ "(" (repr-tail x)))
      otherwise (js:toString x)))

;; Debug utils
(def console (ffi "
  (function (x) {
    console.log(x);
    return null;
  })
"))

;; test
(defun (fact n)
  (defun (_fact acc i)
    (if (<= i 1)
      acc
      (_fact (* acc i) (- i 1))))
  (_fact 1 n))
