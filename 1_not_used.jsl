;;; Stuff that isn't used right now (or ever)

;;; midir to lambdas

(defun (compile-midir-to-lambdas m next)
  (defun (compile-next next2)
    (compile-midir-to-lambdas next2 next))
  (defun (return v)
    (fun (env) v))
  (defun (bind a f)
    (fun (env) ((f (a env)) env)))
  (destruct m
    (midir:lit s next2)
      (let (c2 (compile-next next2))
        (const (bind (return s) c2)))
    (midir:lookup s next2)
      (let (c2 (compile-next next2))
        (const (bind (fun (env)
                       (env 'lookup s))
                     c2)))
    (midir:glookup s next2)
      (let (c2 (compile-next next2))
        (const (bind (fun (env)
                       (env 'lookup s)) ; could be different
                     c2)))
    (midir:enter args varg defs next2)
      (let (c2 (compile-next next2))
        (defun (add-args d args varg arguments)
          (if (and (nil? args) (null? varg) (not (nil? arguments)))
                (error "Too many arguments passed to function.")
              (nil? args)
                (do (if (not (null? varg))
                      (d 'set! varg arguments))
                    d)
              (nil? arguments)
                (error "Too few arguments passed to function.")
              otherwise
                (do (d 'set! (head args) (head arguments))
                    (add-args d (tail args) varg (tail arguments)))))
        (fun (v-env)
          (fun arguments
            (let (env2 (add-args (make-env v-env) args varg arguments))
              ((c2 null) env2)))))
    (midir:return)
      (fun (v) (fun (env) v))
    (midir:bind v next2)
      (let (c2 (compile-next next2))
        (fun (val)
          (fun (env)
            (env 'set! v val)
            ((c2 null) env))))
    (midir:if con alt next2)
      (let (c2 (compile-next next2))
        (let (con2 (compile-midir-to-lambdas con null)
              alt2 (compile-midir-to-lambdas alt null))
          (fun (v)
            (bind ((if v con2 alt2) null) c2))))
    (midir:leave)
      (fun (v) (fun (env) v))
    (midir:funcall f args next2)
      (let (c2 (compile-next next2))
        (fun (v)
          (fun (env)
            (let (fv (env 'lookup f)
                  argsv (map (fun (a) (env 'lookup a)) args))
              ((c2 (apply fv argsv)) env))))) ; TODO
    (midir:closure f next2)
      (let (fc (compile-midir-to-lambdas f null)
            c2 (compile-next next2))
        (const (bind fc c2)))
    (midir:set! v next2)
      (let (c2 (compile-next next2))
        (fun (val)
          (fun (env)
            (env 'set! v val)
            ((c2 null) env))))
    (midir:ffi code outvar next2)
      (let (c2 (compile-next next2))
        (error "midir:ffi in lambdas eval is out of date")
        (fun (val)
          (fun (env)
            ((c2 (js:eval code)) env))))
    (error (++ "Unknown midir " (repr m)))))
